#!/usr/bin/env python3

# rainbow 
#
# Copyright (C) 2020 Adrian Carpenter (adrian@nedrysoft.com)
# 
# Permission is hereby granted, free of charge, to any person obtaining a 
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#

# Tool for extracting information on ZX Spectrum/ZX Spectrum Next sources & documents.
#
# Produces a JSON document which can then be used to produce assembler include files, C headers, documentation as per the users style or requirements.
#
# Credits:
# 
# [ZX Spectrum ROM Dissassemblies](https://github.com/ZXSpectrumVault/rom-disassemblies/tree/master/Spectrum%2048K/Spectrum48.asm)
# [NextZXOS+esxDOS API Docuementation](https://gitlab.com/thesmog358/tbblue/-/blob/master/docs/nextzxos/NextZXOS_and_esxDOS_APIs.pdf)
# [ZX Spectrum NextReg Definitions](https://gitlab.com/SpectrumNext/ZX_Spectrum_Next_FPGA/-/blob/master/cores/zxnext/nextreg.txt)

import json
import sys
import pdftotext
import re
import argparse
import subprocess
import os
import datetime

def parsePlus3Source(filename, arch, source):
	functionTable = []

	header_match = re.compile("(?i)^;(\s*)The DOS routines jump block(\s*)$")
	function_match = re.compile("(?i)^\.l(?P<address>[0-9|a-f]*)(.*);(\s*)(?P<name>.*)(\s*)$")

	try:
		with open(filename) as fp:
			line = fp.readline()
			
			lines = []

			while line:
				line = fp.readline()

				m = header_match.match(line)

				if m:
					while line:
						line = fp.readline()

						m = function_match.match(line)

						if m:
							break;

					while(line):
						m = function_match.match(line)

						if not m:
							break

						newEntry = {}

						newEntry["name"] = m.group('name').upper()
						newEntry["address"] = "{0:#0{1}x}".format(int(m.group('address'), 16),6)

						functionTable.append(newEntry)

						line = fp.readline()
	except:
		print("Error: Unable to load "+filename+", skipping.", file=sys.stderr)

	return [{"arch":arch, "source:":source, "functions":functionTable}]

def parseSource(filename, arch, startAtAddress, source):
	functionTable = []

	label_match = re.compile("(?i)^L(?P<hex>[0-9|a-f]*):.*$")
	description_match = re.compile("(?i)^;;(\s*)(?P<name>[a-z|0-9|_|-]*)(\s*)$")
	comment_match = re.compile("(?i)^;(\s*)(\-*)$")

	ignore_matches = []

	ignore_matches.append(re.compile("(?i)^\(offset\:(\s*)\$([0-9|a-f]*)(.*)\)$"))
	ignore_matches.append(re.compile("(?i)^\(offset(\s*)\$([0-9|a-f]*)\:(.*)\)$"))

	try:
		with open(filename) as fp:
			line = fp.readline()
			
			lines = []

			while line:
				line = fp.readline()

				lines.append(line)

				m = description_match.match(line)
				
				if m:
					name = m.group('name')

					description = []

					for previousLine in reversed(lines[0:-1]):

						m = comment_match.match(previousLine)

						if m:
							break

						description.append(previousLine)

					label = fp.readline()

					m = label_match.match(label)

					if m:
						address = m.group('hex')

						newEntry = {}

						newEntry["name"] = name.upper()
						newEntry["address"] = "{0:#0{1}x}".format(int(address, 16),6)

						commentBlock = ""

						for commentLine in reversed(description):
							commentIndex = commentLine.find(";")

							if (not commentIndex == -1):
								commentLine = commentLine[commentIndex+1:].lstrip().rstrip();

								ignoreLine = False

								for match in ignore_matches:
									m = match.match(commentLine)

									if m:
										ignoreLine = True
										break

								if ignoreLine==False:
									commentBlock += commentLine+"\n"

						newEntry["description"] = commentBlock

						if (int(address,16)>=startAtAddress):
							functionTable.append(newEntry)

					lines = []

					while line:
						line = fp.readline()

						m = comment_match.match(line)

						if m:
							break
	except:
		print("Error: Unable to load "+filename+", skipping.", file=sys.stderr)

	return [{"arch":arch, "source:":source, "functions":functionTable}]

def parseNextDoc(filename, arch, source):
	functionTable = []

	with open(filename, "rb") as fp:
		pdf = pdftotext.PDF(fp)

		pageLines = []

		api_match_1 = re.compile("(?i)^(?P<hex>[0-9|a-f]*)h(\s*)\((?P<dec>[0-9]*)\)$")
		api_match_2 = re.compile("(?i)^(?P<name>[a-z|_]*)(\s*)\(\$(?P<hex>[0-9|a-f]*)\)$")
		api_match_3 = re.compile("(?i)^;(\s*)\*\s(?P<name>[a-z|_]*)\s\(\$(?P<hex>[0-9|a-f]*)\)(\s*)\*$")

		for page in pdf:
			pageLines += page.splitlines()[:-2]

		previousLines = []

		for line in pageLines:
			m = api_match_1.match(line)

			hexValue = None
			functionName = None

			if m:
				hexValue = m.group('hex');
				functionName = previousLines[-1];

				previousLines = []
			else:
				m = api_match_2.match(line)

				if m:
					functionName = m.group('name');
					hexValue = m.group('hex');
				else:
					m = api_match_3.match(line)
					if m:
						functionName = m.group('name');
						hexValue = m.group('hex');

			if hexValue and functionName:
				hexValue = "{0:#0{1}x}".format(int(hexValue, 16),6)

				newEntry = {}

				newEntry["name"] = functionName.upper()
				newEntry["address"] = hexValue

				functionTable.append(newEntry)

			previousLines.append(line)

	return [{"arch":arch, "source:":source, "functions":functionTable}]

def parseNextRegs(filename):
	registerTable = []

	register_match = re.compile("(?i)^0x(?P<hex>[0-9|A-F]*)(\s*)\(([0-9]*)\)(\s*)=>(\s*)(?P<name>.*)(\s*)$")

	try:
		with open(filename) as fp:
			line = fp.readline()

			while line:
				m = register_match.match(line)

				if m:
					hexValue = "{0:#0{1}x}".format(int(m.group('hex'), 16),6)

					entry = {
						"name": m.group('name'), 
						"address" : hexValue
					}

					registerTable.append(entry)

				line = fp.readline()
	except:
		print("Error: Unable to load "+filename+", skipping.", file=sys.stderr)

	return registerTable

def execute(command):
    output = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return(output.returncode, output.stdout.decode('utf-8'))

def which(appname):
    command = 'which'

    status, output = execute(f'{command} {appname}')

    if status and output:
        return(output.split()[0])

# application entry point

parser = argparse.ArgumentParser(description='Rainbow ZX Spectrum/Next development tool')

parser.add_argument('--download', type=str, nargs='?', help='Download the required source documents.')
parser.add_argument('--createjson', type=str, nargs='?', help='Generate the JSON document.')
parser.add_argument('-of','--output', type=str, nargs='?')

args = parser.parse_args()

curl = which('curl')

if curl:
	print('Fatal: curl is required but could not be found.')
	exit(1)

romTable = []
nextRegsTable = []

# prepare for download 

if not os.path.exists("./sources"):
	os.makedirs("./sources")

urlList = [
	"https://raw.githubusercontent.com/ZXSpectrumVault/rom-disassemblies/master/Spectrum%2048K/Spectrum48.asm",
	"https://raw.githubusercontent.com/ZXSpectrumVault/rom-disassemblies/master/Spectrum%20128K/Spectrum128_ROM1.asm",
	"https://raw.githubusercontent.com/ZXSpectrumVault/rom-disassemblies/master/Spectrum%20128K%20%2B3/Spectrum+3_V4-0_ROM2.asm",
	"https://gitlab.com/thesmog358/tbblue/-/raw/master/docs/nextzxos/NextZXOS_and_esxDOS_APIs.pdf",
	"https://gitlab.com/SpectrumNext/ZX_Spectrum_Next_FPGA/-/raw/master/cores/zxnext/nextreg.txt"
]

# download required files from the url list

for url in urlList:
	resultCode, resultOutput = execute(f'cd ./sources; curl -LJO {url}')

# use the 48K, 128K and +3 rom source files to extract the ROM function entry points.  Use the NextZXOS & esxDOS reference manual to get NEXT function entry ppints.

romTable += parseSource("./sources/Spectrum48.asm", "48K", 0x0000, "https://raw.githubusercontent.com/ZXSpectrumVault/rom-disassemblies")
romTable += parseSource('./sources/Spectrum128_ROM1.asm', "128K", 0x386E, "https://raw.githubusercontent.com/ZXSpectrumVault/rom-disassemblies")
romTable += parsePlus3Source("./sources/Spectrum+3_V4-0_ROM2.asm", "128K+3", "https://raw.githubusercontent.com/ZXSpectrumVault/rom-disassemblies")
romTable += parseNextDoc("./sources/NextZXOS_and_esxDOS_APIs.pdf", "NEXT", "https://gitlab.com/SpectrumNext")

# use the nextregs.txt file to obtain the NextReg definitions

nextRegsTable += parseNextRegs("./sources/nextreg.txt")

# create JSON output

doc = {
	"DETAILS": {
		"info":"this file was automatically generated using the rainbow tool.",
		"url":"https://github.com/fizzyade/rainbow",
		"created":str(datetime.datetime.now())
	},
	"ROM" : romTable,
	"NEXTREGS" : nextRegsTable
}

if args.output:
	sys.stdout = open(args.output, "w")

print(json.dumps(doc, indent=4))



