#!/usr/bin/env python3

# rainbow 
#
# Copyright (C) 2020 Adrian Carpenter (adrian@nedrysoft.com)
# 
# Permission is hereby granted, free of charge, to any person obtaining a 
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#

# Tool for extracting information on ZX Spectrum/ZX Spectrum Next sources & documents.
#
# Produces a JSON document which can then be used to produce assembler include files, C headers, documentation as per the users style or requirements.
#
# Credits:
#
# Requires the following files to be placed in the sources folder:
# 
# * [48K ROM Dissassembly](https://github.com/ZXSpectrumVault/rom-disassemblies/tree/master/Spectrum%2048K/Spectrum48.asm)
# * [128K ROM Dissassembly](https://github.com/ZXSpectrumVault/rom-disassemblies/tree/master/Spectrum%20128K/Spectrum128_ROM1.asm)
# * [128K+3 ROM Dissassembly](https://github.com/ZXSpectrumVault/rom-disassemblies/tree/master/Spectrum%20128K%20%2B3/Spectrum+3_V4-0_ROM2.asm)
# * [NextZXOS+esxDOS API Docuementation](https://gitlab.com/thesmog358/tbblue/-/blob/master/docs/nextzxos/NextZXOS_and_esxDOS_APIs.pdf)
#
# The ZX Spectrum Next registers document is also scanned and information extracted, the following file is required:
#
# https://gitlab.com/SpectrumNext/ZX_Spectrum_Next_FPGA/-/blob/master/cores/zxnext/nextreg.txt

import json
import sys
import pdftotext
import re

def parsePlus3Source(filename):
	functionTable = []

	header_match = re.compile("^;(\s*)The DOS routines jump block(\s*)$")
	function_match = re.compile("(?i)^\.l(?P<address>[0-9|a-f]*)(.*);(\s*)(?P<name>.*)(\s*)$")

	try:
		with open(filename) as fp:
			line = fp.readline()
			
			lines = []

			while line:
				line = fp.readline()

				m = header_match.match(line)

				if m:
					while line:
						line = fp.readline()

						m = function_match.match(line)

						if m:
							break;

					while(line):
						m = function_match.match(line)

						if not m:
							break

						newEntry = {}

						newEntry["name"] = m.group('name').upper()
						newEntry["address"] = "{0:#0{1}x}".format(int(m.group('address'), 16),6)
						newEntry["machine"] = "128K+3"

						functionTable.append(newEntry)

						line = fp.readline()
	except:
		print("Error: Unable to load "+filename+", skipping.", file=sys.stderr)

	return functionTable

def parseSource(filename, machine, startAtAddress):
	functionTable = []

	label_match = re.compile("^L(?P<hex>[0-9|A-F|a-f]*):.*$")
	description_match = re.compile("^;;(\s*)(?P<name>[A-Z|a-z|0-9|_|-]*)(\s*)$")
	comment_match = re.compile("^;(\s*)(\-*)$")

	ignore_matches = []

	ignore_matches.append(re.compile("(?i)^\(offset\:(\s*)\$([0-9|A-F|a-f]*)(.*)\)$"))
	ignore_matches.append(re.compile("(?i)^\(offset(\s*)\$([0-9|A-F|a-f]*)\:(.*)\)$"))

	try:
		with open(filename) as fp:
			line = fp.readline()
			
			lines = []

			while line:
				line = fp.readline()

				lines.append(line)

				m = description_match.match(line)
				
				if m:
					name = m.group('name')

					description = []

					for previousLine in reversed(lines[0:-1]):

						m = comment_match.match(previousLine)

						if m:
							break

						description.append(previousLine)

					label = fp.readline()

					m = label_match.match(label)

					if m:
						address = m.group('hex')

						newEntry = {}

						newEntry["name"] = name.upper()
						newEntry["address"] = "{0:#0{1}x}".format(int(address, 16),6)
						newEntry["machine"] = machine

						commentBlock = ""

						for commentLine in reversed(description):
							commentIndex = commentLine.find(";")

							if (not commentIndex == -1):
								commentLine = commentLine[commentIndex+1:].lstrip().rstrip();

								ignoreLine = False

								for match in ignore_matches:
									m = match.match(commentLine)

									if m:
										ignoreLine = True
										break

								if ignoreLine==False:
									commentBlock += commentLine+"\n"

						newEntry["description"] = commentBlock

						if (int(address,16)>=startAtAddress):
							functionTable.append(newEntry)

					lines = []

					while line:
						line = fp.readline()

						m = comment_match.match(line)

						if m:
							break
	except:
		print("Error: Unable to load "+filename+", skipping.", file=sys.stderr)

	return functionTable

def parseNextDoc(filename):
	functionTable = []

	with open(filename, "rb") as fp:
		pdf = pdftotext.PDF(fp)

		pageLines = []

		api_match_1 = re.compile("^(?P<hex>[0-9|A-F|a-f]*)h(\s*)\((?P<dec>[0-9]*)\)$")
		api_match_2 = re.compile("^(?P<name>[a-z|A-Z|_]*)(\s*)\(\$(?P<hex>[0-9|A-F|a-f]*)\)$")
		api_match_3 = re.compile("^;(\s*)\*\s(?P<name>[A-Z|_]*)\s\(\$(?P<hex>[0-9|a-f|A-F]*)\)(\s*)\*$")

		for page in pdf:
			pageLines += page.splitlines()[:-2]

		previousLines = []

		for line in pageLines:
			m = api_match_1.match(line)

			hexValue = None
			functionName = None

			if m:
				hexValue = m.group('hex');
				functionName = previousLines[-1];

				previousLines = []
			else:
				m = api_match_2.match(line)

				if m:
					functionName = m.group('name');
					hexValue = m.group('hex');
				else:
					m = api_match_3.match(line)
					if m:
						functionName = m.group('name');
						hexValue = m.group('hex');

			if hexValue and functionName:
				hexValue = "{0:#0{1}x}".format(int(hexValue, 16),6)

				newEntry = {}

				newEntry["name"] = functionName.upper()
				newEntry["address"] = hexValue
				newEntry["machine"] = "NEXT"

				functionTable.append(newEntry)

			previousLines.append(line)

	return functionTable

# use the 48K, 128K and +3 rom source files to extract the ROM function entry points.  Use the NextZXOS & esxDOS reference manual to get NEXT function entry ppints.

romTable = []

romTable += parseSource("./sources/Spectrum48.asm", "48K", 0x0000)
romTable += parseSource('./sources/Spectrum128_ROM1.asm', "128K", 0x386E)
romTable += parsePlus3Source("./sources/Spectrum+3_V4-0_ROM2.asm")
romTable += parseNextDoc("./sources/docs_nextzxos_NextZXOS_and_esxDOS_APIs.pdf")

# use the nextregs.txt file to obtain the NextReg definitions

nextRegsTable = []

doc = {
	"ROM" : romTable,
	"NEXTREGS" : nextRegsTable
}

print(json.dumps(doc, indent=4))



